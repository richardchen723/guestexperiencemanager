{% extends "base.html" %}

{% block title %}Ticket #{{ ticket.ticket_id }} - Hostaway Insights Dashboard{% endblock %}

{% block content %}
<div class="ticket-detail-page">
    <div class="ticket-detail-header">
        <div>
            <h2>Ticket #{{ ticket.ticket_id }}: {{ ticket.title }}</h2>
            <div class="ticket-badges">
                <span class="status-badge status-{{ ticket.status.lower().replace(' ', '-') }}">{{ ticket.status }}</span>
                <span class="priority-badge priority-{{ ticket.priority.lower() }}">{{ ticket.priority }}</span>
                {% if ticket.category %}
                <span class="category-badge category-{{ ticket.category }}">{{ ticket.category|title }}</span>
                {% else %}
                <span class="category-badge category-other">Other</span>
                {% endif %}
            </div>
        </div>
        <div class="ticket-actions">
            {% if current_user.user_id == ticket.created_by or current_user.user_id == ticket.assigned_user_id or current_user.is_admin() %}
            <a href="{{ url_for('tickets.ticket_edit_form', ticket_id=ticket.ticket_id) }}" class="btn-secondary">Edit</a>
            {% endif %}
            {% if current_user.is_admin() %}
            <button onclick="deleteTicket({{ ticket.ticket_id }})" class="btn-danger">Delete</button>
            {% endif %}
        </div>
    </div>
    
    <div class="ticket-detail-content">
        <div class="ticket-info">
            <div class="info-section">
                <h3>Details</h3>
                <div class="info-row">
                    <label>Issue:</label>
                    <span>{{ ticket.issue_title }}</span>
                </div>
                <div class="info-row">
                    <label>Property:</label>
                    <span>
                        {% if ticket.listing_id %}
                        {% if listing %}
                            <a href="/insights/{{ listing.listing_id }}">{{ listing.internal_listing_name or listing.name }}</a>
                            {% else %}
                            Listing #{{ ticket.listing_id }}
                            {% endif %}
                        {% else %}
                        General (No specific property)
                        {% endif %}
                    </span>
                </div>
                <div class="info-row">
                    <label>Description:</label>
                    <span class="ticket-description-text">{{ ticket.description or 'No description' }}</span>
                </div>
                <div class="info-row">
                    <label>Status:</label>
                    <select id="statusSelect" onchange="updateStatus({{ ticket.ticket_id }})">
                        <option value="Open" {% if ticket.status == 'Open' %}selected{% endif %}>Open</option>
                        <option value="Assigned" {% if ticket.status == 'Assigned' %}selected{% endif %}>Assigned</option>
                        <option value="In Progress" {% if ticket.status == 'In Progress' %}selected{% endif %}>In Progress</option>
                        <option value="Blocked" {% if ticket.status == 'Blocked' %}selected{% endif %}>Blocked</option>
                        <option value="Resolved" {% if ticket.status == 'Resolved' %}selected{% endif %}>Resolved</option>
                        <option value="Closed" {% if ticket.status == 'Closed' %}selected{% endif %}>Closed</option>
                    </select>
                </div>
                <div class="info-row">
                    <label>Priority:</label>
                    <select id="prioritySelect" onchange="updatePriority({{ ticket.ticket_id }})">
                        <option value="Low" {% if ticket.priority == 'Low' %}selected{% endif %}>Low</option>
                        <option value="Medium" {% if ticket.priority == 'Medium' %}selected{% endif %}>Medium</option>
                        <option value="High" {% if ticket.priority == 'High' %}selected{% endif %}>High</option>
                        <option value="Critical" {% if ticket.priority == 'Critical' %}selected{% endif %}>Critical</option>
                    </select>
                </div>
                <div class="info-row">
                    <label>Category:</label>
                    <select id="categorySelect" onchange="updateCategory({{ ticket.ticket_id }})">
                        <option value="other" {% if not ticket.category or ticket.category == 'other' %}selected{% endif %}>Other</option>
                        <option value="cleaning" {% if ticket.category == 'cleaning' %}selected{% endif %}>Cleaning</option>
                        <option value="maintenance" {% if ticket.category == 'maintenance' %}selected{% endif %}>Maintenance</option>
                        <option value="online" {% if ticket.category == 'online' %}selected{% endif %}>Online</option>
                        <option value="technology" {% if ticket.category == 'technology' %}selected{% endif %}>Technology</option>
                        <option value="review management" {% if ticket.category == 'review management' %}selected{% endif %}>Review Management</option>
                    </select>
                </div>
                <div class="info-row">
                    <label>Assigned To:</label>
                    <select id="assignedSelect" onchange="updateAssignment({{ ticket.ticket_id }})">
                        <option value="">Unassigned</option>
                    </select>
                </div>
                <div class="info-row">
                    <label>Due Date:</label>
                    <input type="date" id="dueDateInput" value="{{ ticket.due_date.strftime('%Y-%m-%d') if ticket.due_date else '' }}" onchange="updateDueDate({{ ticket.ticket_id }})">
                </div>
                {% if ticket.is_recurring %}
                <div class="info-row" style="background: var(--bg-secondary); padding: var(--space-3); border-radius: var(--radius-md); margin-top: var(--space-3);">
                    <div style="display: flex; align-items: center; gap: var(--space-2); margin-bottom: var(--space-2);">
                        <span style="font-weight: 600;">ðŸ”„ Recurring Task</span>
                        <span id="recurringStatusBadge" class="status-badge" style="background: {% if ticket.is_recurring_active %}var(--success){% else %}var(--text-tertiary){% endif %}; color: white; font-size: var(--text-xs); padding: 2px 8px;">
                            {% if ticket.is_recurring_active %}Active{% else %}Inactive{% endif %}
                        </span>
                    </div>
                    <div style="font-size: var(--text-sm); color: var(--text-secondary); margin-bottom: var(--space-2);">
                        Recurs every {{ ticket.frequency_value }} {{ ticket.frequency_unit }}
                    </div>
                    <div style="font-size: var(--text-sm); color: var(--text-secondary); margin-bottom: var(--space-2);">
                        Reopens {{ ticket.reopen_days_before_due_date or 10 }} days before due date
                    </div>
                    {% if ticket.initial_due_date %}
                    <div style="font-size: var(--text-sm); color: var(--text-secondary);">
                        Initial due date: {{ ticket.initial_due_date.strftime('%Y-%m-%d') }}
                    </div>
                    {% endif %}
                    <div style="margin-top: var(--space-3);">
                        <button id="toggleRecurringBtn" onclick="toggleRecurringActive({{ ticket.ticket_id }})" class="btn btn-secondary btn-sm">
                            {% if ticket.is_recurring_active %}Disable Recurring{% else %}Enable Recurring{% endif %}
                        </button>
                    </div>
                </div>
                {% endif %}
                <div class="info-row">
                    <label>Created:</label>
                    <span>{{ ticket.created_at.strftime('%Y-%m-%d %H:%M') if ticket.created_at else '' }}</span>
                </div>
                <div class="info-row">
                    <label>Created By:</label>
                    <span>{{ ticket.creator.name if ticket.creator else 'Unknown' }}</span>
                </div>
                <div class="info-row">
                    <label>Tags:</label>
                    <div style="width: 100%;">
                        <div id="ticketTagsDisplay" class="tags-display" style="margin-bottom: 0.75rem;"></div>
                        <div id="ticketTagInputContainer"></div>
                    </div>
                </div>
                
                <div class="info-row">
                    <label>Images:</label>
                    <div id="ticketImagesContainer"></div>
                </div>
            </div>
        </div>
        
        <div class="ticket-comments">
            <h3>Comments</h3>
            <div id="commentsContainer" class="comments-container">
                <!-- Comments will be loaded here -->
            </div>
            
            <div class="comment-form">
                <h4>Add Comment</h4>
                <textarea id="commentText" rows="4" placeholder="Enter your comment..."></textarea>
                <div id="commentImagesContainer" style="margin-top: 0.5rem;"></div>
                <button onclick="addComment({{ ticket.ticket_id }})" class="btn-primary">Post Comment</button>
            </div>
        </div>
    </div>
</div>

<script src="/static/js/tags.js"></script>
<script src="/static/js/ticket-images.js"></script>
<script src="/static/js/mention-handler.js"></script>
<script>
let allUsers = [];
let ticketTagInput = null;
let ticketImageUploader = null;

document.addEventListener('DOMContentLoaded', function() {
    loadUsers();
    loadComments({{ ticket.ticket_id }});
    loadTicketTags({{ ticket.ticket_id }});
    initializeTicketImages({{ ticket.ticket_id }});
    initializeCommentImages();
    
    // Add file input for comment images
    const commentForm = document.querySelector('.comment-form');
    if (commentForm && commentImageUploader) {
        const fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = 'image/*';
        fileInput.multiple = true;
        fileInput.style.display = 'none';
        fileInput.id = 'commentImageInput';
        
        fileInput.addEventListener('change', (e) => {
            const files = Array.from(e.target.files);
            files.forEach(file => {
                // Don't reject large files - backend will create thumbnail only
                commentImageUploader.images.push(file);
                
                // Show preview
                const preview = document.getElementById('commentImagesPreview');
                if (preview) {
                    const previewItem = document.createElement('div');
                    previewItem.className = 'comment-image-preview-item';
                    const img = document.createElement('img');
                    img.src = URL.createObjectURL(file);
                    img.className = 'comment-image-preview-thumb';
                    const removeBtn = document.createElement('button');
                    removeBtn.innerHTML = 'Ã—';
                    removeBtn.className = 'comment-image-preview-remove';
                    removeBtn.onclick = () => {
                        commentImageUploader.images = commentImageUploader.images.filter(f => f !== file);
                        previewItem.remove();
                    };
                    previewItem.appendChild(img);
                    previewItem.appendChild(removeBtn);
                    preview.appendChild(previewItem);
                }
            });
            fileInput.value = '';
        });
        
        const uploadBtn = document.createElement('button');
        uploadBtn.type = 'button';
        uploadBtn.className = 'btn-secondary';
        uploadBtn.textContent = 'Attach Images';
        uploadBtn.style.marginTop = '0.5rem';
        uploadBtn.onclick = () => fileInput.click();
        
        const previewContainer = document.getElementById('commentImagesPreview');
        if (previewContainer && previewContainer.parentElement) {
            previewContainer.parentElement.insertBefore(uploadBtn, previewContainer);
            previewContainer.parentElement.insertBefore(fileInput, previewContainer);
        }
    }
});

function loadUsers() {
    fetch('/tickets/api/users')
        .then(response => response.json())
        .then(users => {
            allUsers = users;
            const select = document.getElementById('assignedSelect');
            const currentAssigned = {{ ticket.assigned_user_id if ticket.assigned_user_id else 'null' }};
            
            users.forEach(user => {
                const option = document.createElement('option');
                option.value = user.user_id;
                option.textContent = user.name || user.email;
                if (user.user_id === currentAssigned) {
                    option.selected = true;
                }
                select.appendChild(option);
            });
        })
        .catch(error => console.error('Error loading users:', error));
}

function loadComments(ticketId) {
    fetch(`/tickets/api/tickets/${ticketId}/comments`, {
        method: 'GET'
    })
        .then(response => response.json())
        .then(comments => {
            console.log('Loaded comments:', comments);
            const container = document.getElementById('commentsContainer');
            container.innerHTML = '';
            
            if (comments.length === 0) {
                container.innerHTML = '<p class="no-comments">No comments yet.</p>';
                return;
            }
            
            comments.forEach(comment => {
                console.log('Processing comment:', comment.comment_id, 'images:', comment.images);
                const commentDiv = createCommentElement(comment, ticketId);
                container.appendChild(commentDiv);
            });
        })
        .catch(error => {
            console.error('Error loading comments:', error);
            document.getElementById('commentsContainer').innerHTML = 
                '<p class="error">Error loading comments.</p>';
        });
}

function highlightMentions(text) {
    // Highlight @mentions in text, matching full names when possible
    if (!allUsers || allUsers.length === 0) {
        // Fallback: simple pattern if users not loaded
        return text.replace(/@(\w+)/g, '<span class="mention-highlight">@$1</span>');
    }
    
    // Build user lookup maps
    const usersByFirstName = {};
    const usersByFullName = {};
    allUsers.forEach(user => {
        const name = user.name || user.email;
        const nameLower = name.toLowerCase();
        const nameWords = name.split(' ');
        
        if (nameWords.length > 1) {
            const firstName = nameWords[0].toLowerCase();
            if (!usersByFirstName[firstName]) {
                usersByFirstName[firstName] = [];
            }
            usersByFirstName[firstName].push({
                name: name,
                fullNameLower: nameLower
            });
        }
        
        usersByFullName[nameLower] = name;
    });
    
    // Match @mentions - try to match full names when present
    // First, try to match full names (two words), then fall back to single word
    let result = text;
    const matches = [];
    
    // Try to match full names first: @FirstName LastName
    const fullNamePattern = /@(\w+)\s+(\w+)/g;
    let match;
    while ((match = fullNamePattern.exec(text)) !== null) {
        // Check if this could be a full name
        const firstPart = match[1].toLowerCase();
        const secondPart = match[2].toLowerCase();
        const fullMentionLower = firstPart + ' ' + secondPart;
        
        // Check if it matches a user's full name
        if (usersByFullName[fullMentionLower]) {
            matches.push({
                index: match.index,
                fullMatch: match[0],
                highlightText: '@' + usersByFullName[fullMentionLower],
                isFullName: true
            });
        } else {
            // Check if first name matches and second could be last name
            const matchingUsers = usersByFirstName[firstPart];
            if (matchingUsers) {
                for (const user of matchingUsers) {
                    const userWords = user.name.split(' ');
                    if (userWords.length > 1 && userWords[1].toLowerCase().startsWith(secondPart)) {
                        matches.push({
                            index: match.index,
                            fullMatch: match[0],
                            highlightText: '@' + user.name,
                            isFullName: true
                        });
                        break;
                    }
                }
            }
        }
    }
    
    // Now match single-word mentions that weren't already matched
    const singleWordPattern = /@(\w+)/g;
    while ((match = singleWordPattern.exec(text)) !== null) {
        // Check if this mention is already part of a full name match
        const isPartOfFullMatch = matches.some(m => 
            match.index >= m.index && match.index < m.index + m.fullMatch.length
        );
        
        if (!isPartOfFullMatch) {
            const firstPartLower = match[1].toLowerCase();
            let highlightText = null;
            
            // Check if it matches a first name (and there's only one user with that first name)
            const matchingUsers = usersByFirstName[firstPartLower];
            if (matchingUsers && matchingUsers.length === 1) {
                highlightText = '@' + matchingUsers[0].name;
            } else if (usersByFullName[firstPartLower]) {
                highlightText = '@' + usersByFullName[firstPartLower];
            } else {
                highlightText = '@' + match[1];
            }
            
            matches.push({
                index: match.index,
                fullMatch: match[0],
                highlightText: highlightText,
                isFullName: false
            });
        }
    }
    
    // Sort matches by index in descending order for safe replacement
    matches.sort((a, b) => b.index - a.index);
    
    // Process matches in reverse order to maintain positions
    for (const m of matches) {
        // Replace in result
        const before = result.substring(0, m.index);
        const after = result.substring(m.index + m.fullMatch.length);
        result = before + '<span class="mention-highlight">' + escapeHtml(m.highlightText) + '</span>' + after;
    }
    
    return result;
}

function createCommentElement(comment, ticketId) {
    const div = document.createElement('div');
    div.className = 'comment-item';
    div.setAttribute('data-comment-id', comment.comment_id);
    
    const userName = comment.user_name || comment.user?.name || comment.user_email || comment.user?.email || 'Unknown';
    const userPicture = comment.user_picture_url || comment.user?.picture_url;
    const date = new Date(comment.created_at);
    const currentUserId = {{ current_user.user_id if current_user else 'null' }};
    const isOwnComment = comment.user_id === currentUserId;
    
    // Build images HTML
    let imagesHtml = '';
    if (comment.images && Array.isArray(comment.images) && comment.images.length > 0) {
        console.log(`Rendering ${comment.images.length} images for comment ${comment.comment_id}`);
        imagesHtml = '<div class="comment-images">';
        comment.images.forEach(img => {
            console.log('Comment image:', img);
            imagesHtml += `
                <div class="comment-image-item">
                    <img src="/tickets/api/images/${img.image_id}/thumbnail" 
                         alt="${escapeHtml(img.file_name || 'Image')}"
                         onclick="showImageLightbox(${img.image_id})"
                         class="comment-image-thumb"
                         onerror="console.error('Failed to load image ${img.image_id}'); this.style.display='none';">
                </div>
            `;
        });
        imagesHtml += '</div>';
    } else {
        console.log(`No images for comment ${comment.comment_id}, images:`, comment.images);
    }
    
    // Add delete button if it's the user's own comment
    const deleteButton = isOwnComment ? `
        <button onclick="deleteComment(${comment.comment_id}, ${ticketId})" 
                class="comment-delete-btn" 
                title="Delete comment">
            Delete
        </button>
    ` : '';
    
    div.innerHTML = `
        <div class="comment-header">
            <div class="comment-author">
                ${userPicture ? `<img src="${escapeHtml(userPicture)}" alt="${escapeHtml(userName)}" class="comment-avatar">` : ''}
                <span class="comment-author-name">${escapeHtml(userName)}</span>
            </div>
            <div style="display: flex; align-items: center; gap: 0.75rem;">
            <span class="comment-date">${formatDate(date)}</span>
                ${deleteButton}
            </div>
        </div>
        <div class="comment-text">${highlightMentions(escapeHtml(comment.comment_text))}</div>
        ${imagesHtml}
    `;
    
    return div;
}

function showImageLightbox(imageId) {
    const lightbox = document.createElement('div');
    lightbox.className = 'image-lightbox';
    lightbox.innerHTML = `
        <div class="lightbox-content">
            <button class="lightbox-close">Ã—</button>
            <img src="/tickets/api/images/${imageId}" alt="Image">
        </div>
    `;
    
    document.body.appendChild(lightbox);
    
    const close = () => {
        lightbox.remove();
    };
    
    lightbox.querySelector('.lightbox-close').addEventListener('click', close);
    lightbox.addEventListener('click', (e) => {
        if (e.target === lightbox) close();
    });
    
    document.addEventListener('keydown', function escHandler(e) {
        if (e.key === 'Escape') {
            close();
            document.removeEventListener('keydown', escHandler);
        }
    });
}

let commentImageUploader = null;

function initializeCommentImages() {
    const container = document.getElementById('commentImagesContainer');
    if (!container) return;
    
    commentImageUploader = {
        images: [],
        container: container
    };
    
    container.innerHTML = '<div id="commentImagesPreview" class="comment-images-preview"></div>';
}

function addComment(ticketId) {
    const text = document.getElementById('commentText').value.trim();
    const images = commentImageUploader ? commentImageUploader.images : [];
    
    if (!text && images.length === 0) {
        alert('Please enter a comment or attach an image');
        return;
    }
    
    // First create the comment
    fetch(`/tickets/api/tickets/${ticketId}/comments`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            comment_text: text || '(No text)'
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.error) {
            alert('Error: ' + data.error);
            return;
        }
        
        const commentId = data.comment_id;
        
        // Upload images if any
        if (images.length > 0) {
            const uploadPromises = images.map(file => {
                const formData = new FormData();
                formData.append('image', file);
                return fetch(`/tickets/api/comments/${commentId}/images`, {
                    method: 'POST',
                    body: formData
                }).then(response => {
                    if (!response.ok) {
                        return response.json().then(err => Promise.reject(new Error(err.error || 'Upload failed')));
                    }
                    return response.json();
                });
            });
            
            Promise.all(uploadPromises).then((uploadResults) => {
                console.log('All images uploaded successfully:', uploadResults);
                document.getElementById('commentText').value = '';
                if (commentImageUploader) {
                    commentImageUploader.images = [];
                    const preview = document.getElementById('commentImagesPreview');
                    if (preview) preview.innerHTML = '';
                }
                // Small delay to ensure database commit
                setTimeout(() => {
                    loadComments(ticketId);
                }, 100);
            }).catch(error => {
                console.error('Error uploading comment images:', error);
                alert(`Error uploading images: ${error.message}`);
                document.getElementById('commentText').value = '';
                if (commentImageUploader) {
                    commentImageUploader.images = [];
                    const preview = document.getElementById('commentImagesPreview');
                    if (preview) preview.innerHTML = '';
                }
                // Still reload comments even if image upload fails
                setTimeout(() => {
                    loadComments(ticketId);
                }, 100);
            });
        } else {
        document.getElementById('commentText').value = '';
        loadComments(ticketId);
        }
    })
    .catch(error => {
        console.error('Error adding comment:', error);
        alert('Error adding comment');
    });
}


function updateStatus(ticketId) {
    const status = document.getElementById('statusSelect').value;
    updateTicket(ticketId, { status: status });
}

function updatePriority(ticketId) {
    const priority = document.getElementById('prioritySelect').value;
    updateTicket(ticketId, { priority: priority });
}

function updateCategory(ticketId) {
    const category = document.getElementById('categorySelect').value;
    updateTicket(ticketId, { category: category });
}

function updateAssignment(ticketId) {
    const assignedId = document.getElementById('assignedSelect').value;
    updateTicket(ticketId, { assigned_user_id: assignedId ? parseInt(assignedId) : null });
}

function updateDueDate(ticketId) {
    const dueDate = document.getElementById('dueDateInput').value;
    updateTicket(ticketId, { due_date: dueDate || null });
}

function toggleRecurringActive(ticketId) {
    // Get current state from the button text or badge
    const button = document.getElementById('toggleRecurringBtn');
    const badge = document.getElementById('recurringStatusBadge');
    const isCurrentlyActive = button.textContent.includes('Disable');
    const newActiveState = !isCurrentlyActive;
    
    updateTicket(ticketId, { is_recurring_active: newActiveState }, function(success) {
        if (success) {
            // Update button text
            button.textContent = newActiveState ? 'Disable Recurring' : 'Enable Recurring';
            
            // Update badge
            if (badge) {
                if (newActiveState) {
                    badge.textContent = 'Active';
                    badge.style.background = 'var(--success)';
                } else {
                    badge.textContent = 'Inactive';
                    badge.style.background = 'var(--text-tertiary)';
                }
            }
        }
    });
}

function updateTicket(ticketId, data, onSuccess) {
    fetch(`/tickets/api/tickets/${ticketId}`, {
        method: 'PUT',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(data)
    })
    .then(response => response.json())
    .then(result => {
        if (result.error) {
            alert('Error: ' + result.error);
            if (onSuccess) onSuccess(false);
            location.reload();
        } else {
            if (onSuccess) onSuccess(true);
        }
    })
    .catch(error => {
        console.error('Error updating ticket:', error);
        alert('Error updating ticket');
        if (onSuccess) onSuccess(false);
        location.reload();
    });
}

function deleteTicket(ticketId) {
    if (!confirm('Are you sure you want to delete this ticket? This action cannot be undone.')) {
        return;
    }
    
    fetch(`/tickets/api/tickets/${ticketId}`, {
        method: 'DELETE'
    })
    .then(response => response.json())
    .then(result => {
        if (result.error) {
            alert('Error: ' + result.error);
        } else {
            window.location.href = '/tickets/';
        }
    })
    .catch(error => {
        console.error('Error deleting ticket:', error);
        alert('Error deleting ticket');
    });
}

function deleteComment(commentId, ticketId) {
    if (!confirm('Are you sure you want to delete this comment? This action cannot be undone.')) {
        return;
    }
    
    fetch(`/tickets/api/tickets/${ticketId}/comments/${commentId}`, {
        method: 'DELETE'
    })
    .then(response => response.json())
    .then(result => {
        if (result.error) {
            alert('Error: ' + result.error);
        } else {
            // Reload comments to reflect the deletion
            loadComments(ticketId);
        }
    })
    .catch(error => {
        console.error('Error deleting comment:', error);
        alert('Error deleting comment');
    });
}

function formatDate(date) {
    return new Date(date).toLocaleString('en-US', {
        year: 'numeric',
        month: 'short',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
    });
}

function escapeHtml(text) {
    if (!text) return '';
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

function loadTicketTags(ticketId) {
    fetch(`/tickets/api/tickets/${ticketId}/tags`)
        .then(response => response.json())
        .then(data => {
            // Handle both array and object formats (for backward compatibility)
            let tags = [];
            if (Array.isArray(data)) {
                tags = data;
            } else if (data.tags && Array.isArray(data.tags)) {
                tags = data.tags;
            } else if (data.error) {
                console.error('Error loading tags:', data.error);
                return;
            }
            
            const displayContainer = document.getElementById('ticketTagsDisplay');
            if (displayContainer) {
                renderTags(displayContainer, tags, {
                    showInherited: true,
                    onRemove: (tag, index) => {
                        if (!tag.is_inherited) {
                            removeTicketTag(ticketId, tag.tag_id);
                        }
                    }
                });
            }
            
            // Initialize tag input for adding new tags (empty - existing tags are shown in display area only)
            if (!ticketTagInput) {
                const inputContainer = document.getElementById('ticketTagInputContainer');
                if (inputContainer) {
                    ticketTagInput = new TagInput(inputContainer, {
                        existingTags: [], // Don't show existing tags in input - they're already displayed above
                        onTagsChange: (newTags) => {
                            // When user adds tags in the input, add them to the ticket
                            // Get current tags from display to check for duplicates
                            const currentTagIds = tags.map(t => t.tag_id);
                            const tagsToAdd = newTags.filter(t => {
                                // Only add tags that aren't already in the list
                                // Check by tag_id if available, otherwise by name
                                if (t.tag_id) {
                                    return !currentTagIds.includes(t.tag_id);
                                }
                                // For newly created tags without tag_id yet, check by name
                                const currentTagNames = tags.map(t => t.name.toLowerCase());
                                return !currentTagNames.includes(t.name.toLowerCase());
                            });
                            
                            if (tagsToAdd.length > 0) {
                                // Clear the input immediately before adding tags
                                // This prevents tags from staying in the input area
                                if (ticketTagInput) {
                                    ticketTagInput.setTags([]);
                                }
                                // Add tags to ticket
                                addTicketTags(ticketId, tagsToAdd.map(t => t.name || t));
                            }
                        }
                    });
                }
            }
            
            // Always ensure the tag input is empty after loading tags (tags are only in display area)
            if (ticketTagInput) {
                ticketTagInput.setTags([]);
            }
        })
        .catch(error => {
            console.error('Error loading ticket tags:', error);
        });
}

function addTicketTags(ticketId, tagNames) {
    fetch(`/tickets/api/tickets/${ticketId}/tags`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({ tags: tagNames })
    })
    .then(response => response.json())
    .then(data => {
        if (data.error) {
            alert('Error: ' + data.error);
        } else {
            // Clear the tag input after successfully adding tags
            if (ticketTagInput) {
                ticketTagInput.setTags([]);
            }
            // Reload tags to update the display area
            loadTicketTags(ticketId);
        }
    })
    .catch(error => {
        console.error('Error adding tags:', error);
        alert('Error adding tags');
    });
}

function removeTicketTag(ticketId, tagId) {
    fetch(`/tickets/api/tickets/${ticketId}/tags/${tagId}`, {
        method: 'DELETE'
    })
    .then(response => response.json())
    .then(data => {
        if (data.error) {
            alert('Error: ' + data.error);
        } else {
            loadTicketTags(ticketId);
        }
    })
    .catch(error => {
        console.error('Error removing tag:', error);
        alert('Error removing tag');
    });
}

function initializeTicketImages(ticketId) {
    const container = document.getElementById('ticketImagesContainer');
    if (!container) {
        console.error('ticketImagesContainer not found');
        return;
    }
    
    try {
        ticketImageUploader = new ImageUploader(container, {
            uploadEndpoint: `/tickets/api/tickets/${ticketId}/images`,
            deleteEndpoint: `/tickets/api/tickets/${ticketId}/images`,
            listEndpoint: `/tickets/api/tickets/${ticketId}/images`,
            imageServeUrl: '/tickets/api/images',
            thumbnailUrl: '/tickets/api/images',
            maxFiles: 10,
            maxFileSize: 2 * 1024 * 1024,
            onUploadComplete: (imageData) => {
                console.log('Image uploaded successfully:', imageData);
                // Image is already added to gallery by ImageUploader
            },
            onDeleteComplete: (imageId) => {
                console.log('Image deleted successfully:', imageId);
                // Image is already removed from gallery by ImageUploader
            }
        });
        console.log('ImageUploader initialized for ticket', ticketId);
    } catch (error) {
        console.error('Error initializing ImageUploader:', error);
    }
}
</script>
{% endblock %}
